// 1) Написать ответ - почему массивы в JS являются "неправильными" и совмещают в себе несколько структур данных? Какие ?

// 1.1) Не совсем понимаю что значит "неправильные", могу предположить что в других языках массивы реализованы иначе, 
// а из-за специфики самого JS имеем отличное поведение. Могу предположить, что под "неправильным" поведением имеется в виду:
const arr = [] 
// тип массива - объект
console.log(typeof arr) // object

// возможность динамического изменения и обращения к любой "точке" на массиве
arr[9] = "some value"

// возможность обращения к несуществующим "точкам"
arr[100500]

// наличие "дыр" в НУМЕРОВАННОМ списке не выглядит правильным
console.log(arr.length) // 10 

// ключем массива является строка, а не число
for(let key in arr) {
  console.log(typeof key) // string
}

// логика работы массивов при удалении и добавлении в начало массива условжнена и требует перестановки всех последующих значений
arr.shift()
arr.unshift('some value')

// возможность иметь разные типы данных в массиве
const arr2 = [1, "string", {}]

// возможно, в каких-то ситуациях было бы хорошо иметь указатели на предыдущий и следующий индекс в массиве
arr[3].next().prev() // как-то так...

// 1.2. В моем представлении - массив является нумерованным списком произвольной глубины, из этого можно представить:

// Массив как обычный список по принципу FIFO
// [1,2,3] --> [2,3,4] --> [3,4] --> [4] --> []

// Массив как стек по принципу LIFO
// [1,2,3] --> [1,2] --> [1,2,4] --> [1,2] --> [1] --> []

// массив как представления древовидной структуры, где вложенность - ее новая ветвь
// [[[],[]],[[],[]]]

// массив как связанный список, где через индекс массива мы можем управлять переключением на предудущий и след элемент массива
// [1,2,3,4]



// 2) Привязать контекст объекта к функции logger, чтобы при вызове this.item выводило - some value (Привязать через bind, call, apply)
function logger() {
  console.log(`I output only external context: ${this.item}`);
}
const obj = { item: "AWEsome value" };

const possibleArguments = [1,2,3] 

logger.bind(obj)()
logger.call(obj, ...possibleArguments)
logger.apply(obj, possibleArguments)



// Бонус задание: Реализовать полифил(собственную функцию реализующую встроенную в js) метода bind()

// fun.bind(thisArg[, arg1[, arg2[, ...]]])
// .bind() => "необычный функциональный объект" // NDM

function foo(...rest) {
  console.log("NAME IS " + this.name);
  console.log("REST: ", [rest]);
}
const obj1 = { name: "Иван", foo };
const obj2 = { name: "Светлана" };
const obj3 = { name: "Не должен привязаться" };

function customBind(obj, ...rest) {
  const executor = Object.create(obj);
  executor.context = this;

  return function (...args) {
    return executor.context(...rest, ...args);
  };
}
Function.prototype.customBind = customBind;

obj1.foo.customBind(obj2, 1, 2).customBind(obj3, 3, 4)(5, 6); // NAME IS Svetlana, REST: [1, 2, 3, 4, 5, 6]
